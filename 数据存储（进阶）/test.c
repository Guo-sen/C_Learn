#define _CRT_SECURE_NO_WARNINGS
#include<string.h>
#include<stdio.h>
//整型家族
//char			unsigned char				signed char				//字符在内存中的本质是ASCII值，是整型  //signed char 范围为 -128~127	unsigned char范围为0~255
//short			unsigned short[int]			signed short[int]
//int           unsigned int				signed int
//long          unsigned long[int]			signed long[int]    
// long long    unsigned long long[int]		signed long long[int]   

//范围在limits.h中定义了

//int 默认是signed int
//char 默认是signed char还是unsigned char这是标准未定义的，取决于编译器的实现

//浮点数家族
//float double

//构造类型(自定义类型)：
//数组类型，结构体类型struct，枚举类型enum，联合类型union

//指针类型 
//int* pi
//char* pc
//float* pf
//void* pv


//整型在内存中的存储
//整数的二进制表示形式有3种
//正整数的原码、反码、补码是相同的
//1.原码（二进制序列）
//2.反码（符号位不变，其他位按位取反）
//3.补码（反码+1）

//int main()
//{
//	int a = 20;    // 14 00 00 00 （内存种本质上存的是二进制，但是二进制不方便看，所以以16进制显示）
//	//00000000 00000000 00000000 00010100
////0x	00		00			00		14     16进制：四个二进制为写成1个16进制位
//
//	int b = -10;	//f6 ff ff ff   说明数据在内存中放的是补码
//	//10000000 00000000 00000000 00001010
////0x     80		00         00     0a
//	//11111111 11111111 11111111 11110101
////0x	ff       ff       ff      f5
//	//11111111 11111111 11111111 11110110
////0x	ff		ff			ff		f6
//	return 0;
//}

//大小端介绍（跟硬件有关系）
//大端【字节序】（存储）模式：数据的低位，保存在内存的高地址中，数据的高位，保存在内存的低地址中
//小端【字节序】（存储）模式：数据的低位，保存在内存的低地址中，数据的高位，保存在内存的高地址中


//设计一个小程序来判断当前机器的字节序
//int main()
//{
//	int a = 1;//0x00000001
//	char* pc= &a;
//	if (*pc == 1)
//	{
//		printf("小端\n");
//	}
//	else
//	{
//		printf("大端\n");
//	}
//	return 0;
//}


//思考下列代码打印结果
//int main()
//{
//	char a = -1;				//-1放的时候会发生截断
//	signed char b = -1;			
//	unsigned char c = -1;		
//	printf("%d %d %d\n",a,b,c);//打印的时候会发生整型提升
//	return 0;
//}


//int main()
//{
//	char a = -128;
//	//10000000 00000000 00000000 10000000 -128原码
//	//11111111 11111111 11111111 01111111
//	//11111111 11111111 11111111 10000000 -128补码
//	//10000000 截断后放进a
//
//	//无符号整型打印发生整型提升
//	//11111111 11111111 11111111 10000000
//	printf("%u\n",a);
//	return 0;
//}

//int main()
//{
//	int i = -20;
//	unsigned int j = 10;
//	printf("%d\n",i+j);
//	return 0;
//}


//  int main()
//{
//	  char arr[1000];
//	  int i = 0;
//	  for (i = 0; i < 1000; i++)
//	  {
//		  arr[i] = -1 - i;
//	  }
//	  //-1 -2......-128 127 126 ...0 -1 -2......
//	  printf("%d", strlen(arr));
//	return 0;
//}
 //arr每个元素是char类型-128~127，再大的数字往里放都会发生截断成为-128~127之间的数字

//int main()
//{
//	if (strlen("abc") - strlen("abcdef") >= 0)
//	{
//		printf("hehe\n");
//	}
//	else
//	{
//		printf("haha\n");
//	}
//	return 0;
//}
//strlen返回值是size_t-->unsigned int 无符号数和无符号数的运算结果还是无符号数




//浮点数在内存中的存储
//浮点数家族： floa      double        long double
//浮点数的表示范围：folat.h中定义了
//int main()
//{
//	int n = 9;
//	float* p = (float*)&n;
//	printf("n的值：%d\n",n);
//	printf("*p的值：%f\n",*p);
//
//	*p = 9.0;
//	printf("修改后的n的值：%d\n", n);
//	printf("修改后*p的值：%f\n", *p);
//	/*n的值：9
//	* p的值：0.000000
//	修改后的n的值：1091567616
//	修改后 * p的值：9.000000*/
//
//	return 0;
//}
//以上代码可以看出浮点数在内存中的读取方式和存储方式和整数是不一样的

//浮点数的存储规则
//根据IEEE（电气和电子工程协会）754，任意一个二进制浮点数V可以表示成下边的形式
//  V  = （-1）^S * M * 2^E
//(-1)^S表示符号位，当S=0，V为正数；当S=1，V为负数
//M表示有效数字，大于等于1，小于2
//2^E表示指数位

//举例： V=5.0f  --> 101.0 --> 1.01 * 2^2 --> (-1)^0 * 1.01 * 2^2							S=0   M=1.01      E=2
//		 V=9.5f -->1001.1(小数点后1位，权重为2^-1) -->1.0011*2^3 -->(-1)^0 * 1.0011*2^3		S=0   M=1.0011    E=3
//		 V=9.6f -->1001.100(总是差一点点凑够0.6)	所以浮点数在内存中是有可能无法精确保存的
// IEEE规定 对于32位浮点数，最高的1位是符号位S，接着的8位是指数E，剩下的23位为有效数字M
//          对于64位浮点数，最高的1位是符号位S，接着的11位是指数E，剩下的52位为有效数字M
//IEEE 对有效数字M和E还有一些特别的规定
//1<=M<=2,即M可以写成 1.xxxx的形式，xxxx表示小数部分。IEEE754规定，在计算机内部保存M时，默认的第一位总是1，因此
//可以被舍弃，只保存后面的xxxx部分，比如保存1.01的时候，只保存01，等到读取的时候，再把第1位的1加上去。这样的目的是
//节省一位有效数字。以32位浮点数为例，留给M的只有23位，将第一位的1舍弃后，等于可以保存24位有效数字

//对于指数E，情况就比较复杂
//首先E为一个无符号整数，但是科学计数法中E是可以出现负数的，所以IEEE 754规定写入内存时E的真实值必须加上一个中间数
//对于8位的E，这个中间数是127；对于11位的E这个中间数是1023；比如2^10的E是10，所以保存成32位浮点数时，必须保存成10+127=137
//即10001001

//int main()
//{
//	float f = 5.5;
//	//101.1 
//	//1.011*2^2
//	//S=0 E=2+127=129 M=1.011
//	// 01000000101100000000000000000000
//	// 01000000 10110000 00000000 00000000
////0x    40        b0       00         00//调试起来观察内存中f的值
//
//	return 0;
//}
//

//然后，指数E从内存中取出来还可以分为3种情况
//1. E不全为0或不全为1
//指数E的计算值减去127（或1023），得到真实值，再将有效数字M前加上第一位的1
//2. E为全0
//这时，浮点数的指数E等于1-127（或者1-1023）即为真实值，有效数字不再加上第一位的1，而是还原为0.xxx的小数
// 这样的值用来表示±0，以及接近于0的很小的数字（真实值+127等于全0，说明E真实值很小，假设E真实值为：-127，那么1.XXXXX * 2^127≈1.xxx/2^127≈0）
//3. E为全1
//这时，如果有效数字M全为0，表示±无穷大（符号取决于S）（E真实值可能为128，1.xxxxx * 2^128是一个超级大的数字，2^32次方以及42亿多了）

//回过头来看前边的一个例子
int main()
{
	int n = 9;
	//00000000 00000000 00000000 00001001
	float* p = (float*)&n;
	printf("n的值：%d\n",n);

	printf("*p的值：%f\n",*p);//E为全0，是一个超级小的数字

	// 10000011

	*p = 9.0;
	//1001.0
	//1.001*2^3
	// 0 10000010 00100000000000000000000
	printf("修改后的n的值：%d\n", n); //  01000001000100000000000000000000
	printf("修改后*p的值：%f\n", *p);
	/*n的值：9
	* p的值：0.000000
	修改后的n的值：1091567616
	修改后 * p的值：9.000000*/

	return 0;
}


//int main()
//{
//
//	return 0;
//}