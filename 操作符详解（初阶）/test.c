#define _CRT_SECURE_NO_WARNINGS

#include<stdio.h>
//算数操作符： +  -  *  /  %
//    /  整型的除法      1/2-->  0
//       浮点型的除法    1.0/2--> 0.5    1/2.0--> 0.5   1.0/2.0-->0.5
//    %  计算的是整除之后的余数   7%2--> 1   取模操作符的俩个操作数必须是整数




// 移位操作符（操作数必须是整数） 移动的是二进制位 移动的是补码
//整数的二进制表示形式有3种
// 原码 反码 补码
//正整数 原码、反码、补码都相同 等于 二进制表示
//  7
//  00000000 00000000 00000000 00000111 //整型 7 在内存中的存储

// -7
//  10000000 00000000 00000000 00000111 //整型 -7的原码  最高位为符号位，0表示正数，1表示负数
//  11111111 11111111 11111111 11111000 // 反码  符号位不变，其他位按位取反
//  11111111 11111111 11111111 11111001  //补码  反码+1 
//整数在内存中 存的是补码

//  << 左移操作符
//  左边丢弃，右边空出来的一位补0
//int main()
//{
//	int a = 7;
//	int b = a << 1;
//	printf("a=%d\n",a);
//	printf("b=%d\n", b);
//
//	return 0;
//}
//int main()
//{
//	int a = -7;
//	//-7的补码：     11111111 11111111 11111111 11111001
//	// 移位完后：    11111111 11111111 11111111 11110010
//	//补码-1 求反码：11111111 11111111 11111111 11110001
//	//原码：         10000000 00000000 00000000 00001110
//	int b = a << 1;
//	printf("a=%d\n", a);
//	printf("b=%d\n", b);
//
//	return 0;
//}
// 

//  >> 右移操作符
//  分为两种
//  1.算术移位： 右边丢弃，左边补原符号位	
//  2.逻辑移位： 右边丢弃，左边补0
//int main()
//{
//	int a = 7;
//	int b = a >> 1;
//	printf("a=%d\n",a);
//	printf("b=%d\n", b);
//
//	return 0;
//}
//下段代码说明了vs编译器采用的是算术右移
//int main()
//{
//	int a = -7;
//	//-7的补码：          11111111 11111111 11111111 11111001
//	// 假设算术移位完后： 11111111 11111111 11111111 11111100   
//	//补码-1 求反码：     11111111 11111111 11111111 11111011
//	//原码：              10000000 00000000 00000000 00000100
//	int b = a >> 1;
//	printf("a=%d\n", a);
//	printf("b=%d\n", b);
//	return 0;
//}
// 注意使用移位操作符移位时不可以移动负数位，这是C语言标准未定义的

//   位（二进制位）操作符（操作数必须是整数）
//   & 按位与    有0则0 全1为1
//   | 按位或    有1则1 全0为0
//   ^ 按位异或  相同为0，相异为1

//int main()
//{
//	int a = 3;
//	int b = -5;
//	//int c = a & b;
//	//10000000 00000000 00000000 00000101 -5原码
//	//11111111 11111111 11111111 11111010 -5 反码
//	//11111111 11111111 11111111 11111011 -5 补码
//	//00000000 00000000 00000000 00000011 3(正数原码反码补码相同)
//	//00000000 00000000 00000000 00000011 a&b只要有0就是0，都为1的时候才是1
//	//最高位为0 是正数
//
//	//int c = a | b;
//	//11111111 11111111 11111111 11111011 -5 补码
//	//00000000 00000000 00000000 00000011 3(正数原码反码补码相同)
//	//11111111 11111111 11111111 11111011 a|b 是负数 有1则1 全0为0
//	//11111111 11111111 11111111 11111010 a|b 的反码
//	//10000000 00000000 00000000 00000101 a|b 的原码
//
//	 int c = a ^ b;
//	 //11111111 11111111 11111111 11111011 -5 补码
//	 //00000000 00000000 00000000 00000011 3(正数原码反码补码相同)
//	 //11111111 11111111 11111111 11111000 a^b是负数 相同为0，相异为1
//	 //11111111 11111111 11111111 11110111 a^b 的反码
//	 //10000000 00000000 00000000 00001000 a^b 的原码
//
//	printf("c=%d\n",c);
//	return 0;
//}

//一道变态的面试题 不能创建临时变量，实现两个数字的交换

// 3^3
// 011
// 011
// 000
// a^a--> 0

// 0^5
// 000
// 101
// 101
// 0^a-->a
// 3^3^5 -->5

//3^5^3
// 3^5 011 101 110
// 110^3(011) 101(5)
// 可得 异或操作符支持交换律
// 3^5^3==3^3^5 -->5
//int main()
//{
//	int a = 3;
//	int b = 5;
//	printf("交换前：a=%d b=%d\n",a,b);
//	a = a ^ b;
//	b = a ^ b;
//	a = a ^ b;
//	printf("交换后：a=%d b=%d\n", a, b);
//	return 0;
//}

////练习：编写代码，求一个整数在内存中1的个数
////也就是求补码中1的个数
////int a=3
//// 00000000 00000000 00000000 00000011 3的补码
////a&1
//// 00000000 00000000 00000000 00000001 1的补码
//// 00000000 00000000 00000000 00000001 3&1
////通过上一段和下一段的规律可以发现 某个数和1按位与的结果，可以表示某个数最低位是0还是1
//// 00000000 00000000 00000000 00000010
//// 00000000 00000000 00000000 00000001 1的补码
//// 00000000 00000000 00000000 00000000 某个数和1按位与的结果，可以表示某个数最低位是0还是1
//
//int main()
//{
//	int n = 0;
//	int count = 0;
//	printf("请输入一个数字：");
//	scanf("%d",&n);
//	int i = 0;
//	printf("%d在内存中1的个数为",n);
//	while (i < 32)
//	{
//		if ((n & 1) == 1)
//		{
//			count++;
//		}
//		n=n >> 1;
//		i++;
//	}
//	printf("%d\n",count);
//	return 0;
//}








//赋值操作符  =
//赋值操作符可以连续使用
//int a=10; int x=0;int y=20; a=x=y+1;  先把y+1赋值给x 再把x赋值给a
//复合赋值符号
// +=  -=   *=  /=  %=  >>=  <<=   &=  |=  ^=



//单目操作符（只有一个操作数）
// !        逻辑反操作(把真变成假，把假变成真。C语言中0表示假，非0表示真)
// -        负值
// +        正值
// &        取地址（取出的是变量在内存中的起始地址）
// sizeof   操作数（变量）的类型长度（单位是字节）
// ~		对一个数的二进制位按位取反
// --		前置-- 后置--
// ++		前置++ 后置++
// *		间接访问操作符（解引用操作符）
//(类型)    强制类型转换
//

//int main()
//{
//	int flag = 3;
//	printf("%d\n",!flag);
//	return 0;
//}
//
//int main()
//{
//	int a = 0;
//	// 00000000 00000000 00000000 00000000 a
//	// 11111111 11111111 11111111 11111111 ~a 补码
//	// 11111111 11111111 11111111 11111110 ~a 反码
//	// 10000000 00000000 00000000 00000001
//	printf("%d\n",~a);
//
//	return 0;
//}
//
// 假设想把末尾1101 改成1111
// 可以让13 或 (1<<1)
// 00000000 00000000 00000000 00001101   13




//int main()
//{
//	int a = 3;
//	int b = ++a;
//	printf("%d %d\n",a,b);// 4 4
//	return 0;
//}

//int main()
//{
//	
//	int a = (int)3.14;
//	printf("%d\n", a);
//	printf("%d\n",sizeof a);//可以
//	//printf("%d\n", sizeof int);//不可以
//
//	return 0;
//}



//关系操作符 >  <  <=  >=  ==  !=
// 字符串和字符串相同不相同 不能用 == 应该用 strcmp


//逻辑操作符   &&  逻辑与  || 逻辑或
//				   并且       或者
//只关注真假

//int main()
//{
//	int a = 3;
//	int b = 5;
//	int c = a && b; //1
//	printf("%d\n",c);
//	return 0;
//}
//

//int main()
//{
//	int i = 0, a = 0, b = 2, c = 3, d = 4;
//	//i = a++ && ++b && d++; //a为0 是假  后边的就不算了 但是判断完 a会自增
//	i=a++||++b||d++;//a为0是假，然后自增，++b为真，所以后边不算了
//	printf("a=%d\nb=%d\nc=%d\nd=%d\n",a,b,c,d);
//
//	return 0;
//}


// 条件操作符（三目操作符）
// exp1?exp2:exp3
// exp1 为真，exp2 算 exp3不算 exp2的结果就是整个表达式的结果
// exp1 为假，exp2 不算 exp3算 exp3的结果就是整个表达式的结果
//int main()
//{
//	int a = 5;
//	int b = 0;
//	(a > 5 )? (b = 3) : (b = -3);
//	b = (a > 5 ? 3 : -3);
//	return 0;
//}

//逗号表达式
//exp1,exp2,exp3....expN
//从左到右依次计算，整个表达式的结果是最后一个表达式的结果

//int main()
//{
//	int a = 5;
//
//	a = get_val();
//	count_val(a);
//	while (a > 0)
//	{
//		a = get_val();
//		count_val(a);
//	}
//
//	//上段代码可以改为
//	while (a = get_val(),count_val(a),a>0)
//	{
//	
//	}
//
//	return 0;
//}

//下标引用 函数调用，结构成员 操作符
//  []       ()       .    ->
//                   结构体.成员名
//					结构体指针->成员名

//int main()
//{
//	int arr[10] = {0};
//
//	arr[7] = 5;
//	7[arr] = 10;
//	//以上两种写法都没问题
//	//arr[7] = 5;  --> *(arr+7)
//	//arr是首元素的地址，arr+7就算跳过七个元素，指向了第八个元素  *(arr+7)就是第八个元素
//	// *（7+arr）也是成立的，因为加法交换律 --> 7[arr]
//	return 0;
//}

//struct Stu
//{
//	char name[20];
//	int age;
//	double score;
//
//};
//void set_stu(struct Stu* ps)
//{
//	ps->age = 20;
//	(*ps).score=60.0;
//	strcpy((*ps).name,"张三");
//}
////ps->name等价于 *（ps）.name
//void print_stu(struct Stu s)
//{
//	printf("%s %d %lf\n",s.name,s.age,s.score);
//}
//
//int main()
//{
//	struct Stu s = { 0 };
//	set_stu(&s);
//	print_stu(s);
//	return 0;
//}


//表达式求值
//表达式求值的顺序一般是由操作符的优先级和结合性决定
//有些表达式的操作数在求值的过程中可能需要转化为其他类型

//隐式类型转换 
// C语言的整型算术运算总是至少以缺省（默认）整型类型的精度来进行的
// 
//为了获得这个精度，表达式中的字符和短整型操作数在使用之前被转化为普通整型，这种转换称为整型提升



//整型提升是按照变量的数据类型的符号位来提升的
//char c1=-1;
//  -1 补码： 11111111 11111111 11111111 11111111
// 四个字节，往char里放的时候放不下，只能放下一个字节 发生截断
// c1（1个字节，八个比特位）：11111111（补码）
//提升的时候高位补充符号位：  11111111 11111111 11111111 11111111
//char c2=1
//     c2：		00000001
//   整型提升： 00000000 00000000 00000000 00000001


//int main()
//{
//	char a = 5;
//	// 00000000 00000000 00000000 00000101  5
//	// 00000101  a
//	char b = 126;
//	// 00000000 00000000 00000000 01111110 126
//	// 01111110 b
//	char c = a + b;
//	//在计算时候 发生整型提升 整型提升是按照变量的数据类型的符号位来提升的
//	// 00000000 00000000 00000000 00000101  5
//	// 00000000 00000000 00000000 01111110 126
//	// 00000000 00000000 00000000 10000011  126+5
//	//c ：10000011 往c存的时候发生截断
//
//	printf("%d\n", c);
//	//打印的时候以%d打印，发生整型提升
//	//          10000011 c
//	//补符号位：11111111 11111111 11111111 10000011
//	// 反码：   11111111 11111111 11111111 10000010
//	// 原码：   10000000 00000000 00000000 01111101
//	return 0;
//}



//int main()
//{
//	char a = 0xb6;//10110110
//	short b = 0xb600;
//	int c = 0xb6000000;
//	if (a == 0xb6)
//		printf("a");
//	if (b == 0xb600)
//		printf("b");
//	if (c == 0xb6000000)
//		printf("c");
//	return 0;
//}
//上段代码 a不够一个整型，在使用的时候会发生整型提升，所以就和原来不一样了 b同理
// 所以只会打印一个c
// 如果改成  unsigned char a = 0xb6;就会打印a 因为无符号，高位补0，没什么差别
//

////下段代码也可以表示出来c在参与运算时，会发生整型提升
//int main()
//{
//	char c = 1;
//	printf("%u\n",sizeof(c));  //1
//	printf("%u\n", sizeof(+c));//4
//	printf("%u\n", sizeof(-c));//4
//	return 0;
//}

//算术转换 
// 如果某个操作符的各个操作数都属于不同类型，那么除非其中一个操作数的类型转换为另一个操作数的类型
//否则操作就无法进行。下面的层次体系成为寻常算术转换
// long double
//double
//float
// unsigned long int
//long int
//unsigned int
//int
//如果某个操作数的类型在上边这个列表排名较低，那么首先要转化为另一个操作数的类型，然后执行运算
//但是算术转换要合理，要不然会有潜在的一些问题
// float f=3.14
// int num=f; //隐式转换，会有精度丢失
//


//操作符的属性
// 复杂表达式的求值有三个影响因素
//1.操作符的优先级（相邻操作符讨论优先级）
//2.操作符的结合性 
//3.是否控制求值顺序
//两个相邻操作符先执行哪个呢？ 取决于它们的优先级，如果两者的优先级相同，取决于它们的结合性
//即使知道了以上3点也并不是对于每个表达式都能确定他的计算路径
//	a*b+c*d+e*f
//  可能算 1.a*b  2.c*d  3.前两者的结果加起来 4.e*f   5.  4的结果+3的结果
//  也可能 1.a*b  2.c*d  3.e*f 4. 1的结果加2的结果  5. 4的结果加 3的结果
// 虽然上述表达式结果不管哪种路径，结果一样
// 但是如果a、b、c、d、e、f、不仅仅是简单的变量，而是表达式（比如a*b的执行会影响c或者d的值）
// 所以上述表达式是有问题的--问题表达式
// 在写代码的时候要尽量写出来 具有唯一计算路径的代码 避免写出来 问题表达式

//c+ --c；也是一个问题表达式，虽然知道--的优先级高 
//但是开始的c在什么时候放入寄存器（是在--c之前，还是之后），不能确定可能会发生 1+1 也可能2+1


//

//非法表达式
//int main()
//{
//	int i = 10;
//	i = i-- - --i * (i = -3) * i++ + ++i;
//	printf("i=%d\n",i);
//	return 0;
//}
//上段代码，在不同的编译器下运算出来的结果不同

//int fun()
//{
//	static int count = 1;
//	return ++count;
//}
//
//int main()
//{
//	int answer;
//	answer = fun() - fun() * fun();
//	printf("%d\n",answer);
//	return 0;
//}
//上段代码也是一个错误代码，没有标准答案 函数调用的先后顺序无法通过操作符的优先级来确定


//int main()
//{
//	int i = 1;
//	int ret = (++i) + (++i) + (++i);
//	printf("ret=%d\n", ret);
//	printf("i=%d\n",i);
//	return 0;
//}
//以上代码答案也不唯一，linux gcc编译器下执行结果为10

//int main()
//{
//	return 0;
//}