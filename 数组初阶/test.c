#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
//数组是一组相同类型元素的集合

//创建方式：
//type_t arr_name [const_n]
//type_t 是指数组的元素类型
//cosnst_n是一个常量表达式，用来表示数组的大小
//C99标准之前，数组的大小必须是常量或者常量表达式，
//C99之后可以是变量，支持了变长数组

//数组的初始化：在创建数组的同时，给数组的内容一些合理的初始值（初始化）
//int arr1[10] = { 1,2,3 };			//不完全初始化，剩余的元素默认初始化为0
//int arr2[] = { 1,2,3,4 };		//不指定大小，数组的大小会根据初始化内容来决定	
//int arr3[5] = { 1,2,3,4,5 };
// 
//char arr4[3] = { 'a',98,'c' };
//char arr5[] = { 'a','b','c' };
//char arr6[] = "abcdef";
// 
//char arr7[10]={'a','b','c'}; //不完全初始化，剩余的元素默认初始化为0 即‘\0’
//char arr8[10]="abc";  //不完全初始化，剩余的元素默认初始化为0 即‘\0’ 和上一种相比，结果一样，但是性质不一样

//总结：数组是通过下标来访问的，下标是从0开始的
	//	数组的大小可以通过计算得到（sizeof）

//一维数组在内存中的存储	
//int main()
//{
//	int arr[10] = { 0 };
//	int i = 0;
//	for (i = 0; i < 10; i++)
//	{
//		printf("arr[%d]的地址为：%p\n",i,&arr[i]);
//	}
//
//	return 0;
//}
//arr[0]的地址为：00000054C4AFF6E8
//arr[1]的地址为：00000054C4AFF6EC
//arr[2]的地址为：00000054C4AFF6F0
//arr[3]的地址为：00000054C4AFF6F4
//arr[4]的地址为：00000054C4AFF6F8
//arr[5]的地址为：00000054C4AFF6FC
//arr[6]的地址为：00000054C4AFF700
//arr[7]的地址为：00000054C4AFF704
//arr[8]的地址为：00000054C4AFF708
//arr[9]的地址为：00000054C4AFF70C
//每个元素之间相差4，因为一个整型占4个字节，并且数组在内存中是连续存放的（每个元素地址按一定规律递增）





//二维数组
//int arr[3][4] = { 1,2,3,4,3,4,5,6,4,5,6,7 };//依次往里放
//int arr[3][4] = { 1,2,3,4,3,4,5,6,4 };//依次往里放，不够的补0
//int arr[3][4] = { 1,2,3,4 };
//int arr[3][4] = { {1,2,},{3,4} };
//int arr[][4] = { {1,2},{3,4} };//二维数组如果有初始化，行可以省略，列可以省略


//二维数组也是通过下标来使用的
//int main()
//{
//	int arr[3][4] = { 1,2,3,4,3,4,5,6,4,5,6,7 };
//	int i = 0;
//	for (i = 0; i < 3; i++)
//	{
//		int j = 0;
//		for (j = 0; j < 4; j++)
//		{
//			scanf("%d",&arr[i][j]);
//		}
//		printf("\n");
//	}
//	for (i = 0; i < 3; i++)
//	{
//		int j = 0;
//		for (j = 0; j < 4; j++)
//		{
//			printf("%d ",arr[i][j]);
//		}
//		printf("\n");
//	}
//	return 0;
//}

//可以把二维数组看成一维数组的数组 int add[3][4] 可以把一行看成一个元素，一共有三个元素
//int arr2[10];                 arr2[i]; //i的范围为0~9；
//int arr[3][4];        第一行：arr[0][j]  //可以看成 名为 arr[0]的数组 通过下标j来访问 j的范围为0~3
//						第二行：arr[1][j] 
//						第三行：arr[2][j]




//int main()
//{
//	int arr[3][4] = { 1,2,3,4,3,4,5,6,4,5,6,7 };
//	int i = 0;
//	for (i = 0; i < 3; i++)
//	{
//		int j = 0;
//		for (j = 0; j < 4; j++)
//		{
//			printf("%p ",&arr[i][j]);
//		}
//		printf("\n");
//	}
//	return 0;
//}

//二维数组在内存中也是连续存放的（一行后边紧跟着下一行）
//00000005AF4FF5A8 00000005AF4FF5AC 00000005AF4FF5B0 00000005AF4FF5B4
//00000005AF4FF5B8 00000005AF4FF5BC 00000005AF4FF5C0 00000005AF4FF5C4
//00000005AF4FF5C8 00000005AF4FF5CC 00000005AF4FF5D0 00000005AF4FF5D4
//

//数组越界
// 数组规定下标是从0开始的，如果数组有n个元素，最后一个元素的下标就是n-1
// 如果访问的下标小于0或者大于n-1，就算数组的越界访问了，超出了数组的合法空间的访问
//数组的下标范围是有限的，C语言本身不对数组的下标越界的检查，编译器也不一定报错
//错误示范
//int main()
//{
//	int arr[6] = { 1,2,3,4,5,6 };
//	int i = 0;
//	for (i = 0; i <10; i++)
//	{
//		printf("%d ",arr[i]);
//	}
//	return 0;
//}


//数组作为函数参数
//数组作为函数参数的时候，函数的参数有两种写法
//1.数组的形式
//2.指针的形式 
// 
//冒泡排序函数的核心思想：两个相邻的元素比较，如果比较出来的大小不满足顺序的话，这两个元素交换顺序
// 
// 降序的数列排成升序：
//9 8 7 6 5 4 3 2 1 0 
//8 9 7 6 5 4 3 2 1 0
//8 7 9 6 5 4 3 2 1 0
//.........
//8 7 6 5 4 3 2 1 0 9  一趟排序完成后，9会出现在最终它应该出现在的位置
//接下来排序的时候就不需要关注9，用同样的方法排8 7 6 5 4 3 2 1 0 
//一趟冒泡排序让一个数据出现在最终它应该出现在的位置

//n个元素需要n-1趟  把n-1个数字放在它最终应该出现在的位置，剩下哪一个就不用排了

//错误示范
//void bubble_sort(int arr[])//形参的大小可写可不写（写上也没用）
//{
//	int sz = sizeof(arr) / sizeof(arr[0]); //数组名本质上是首元素的地址，所以传参的时候，传过来的是地址，
//										 // 这里arr看似是数组，本质上是指针变量（要接收传过来的地址）
//	int i = 0;
//	for (i = 0; i < sz - 1; i++)
//	{
//		//一趟冒泡排序 第一趟 10个元素 两两相邻比较 一共9对数字比较；
//		//			   第二趟 9个元素  两两相邻比较 一共8对数字比较；
//		//             第三趟 8个元素  两两相邻比较 一共7对数字比较；
//		int j = 0;
//		for (j = 0; j < sz - i-1; j++)
//		{
//			if (arr[j] > arr[j + 1])
//			{
//				int tmp = arr[j];
//				arr[j] = arr[j + 1];
//				arr[j + 1] = tmp;
//			}
//		}
//	}
//}


//改正
//void bubble_sort(int arr[],int sz)//参数是数组的形式
////void bubble_sort(int* arr,int sz)//参数是指针的形式

//{
//	int i = 0;
//	for (i = 0; i < sz - 1; i++)
//	{
//		
//		int j = 0;
//		for (j = 0; j < sz - i - 1; j++)
//		{
//			if (arr[j] > arr[j + 1])
//			{
//				int tmp = arr[j];
//				arr[j] = arr[j + 1];
//				arr[j + 1] = tmp;
//			}
//		}
//	}
//}
//
//int main()
//{
//	//把数组的排序排成升序
//	int arr[] = { 9,8,7,6,5,4,3,2,1,0 };
//
//	int sz = sizeof(arr) / sizeof(arr[0]);
//	//bubble_sort(arr);
//	bubble_sort(arr,sz);
//	int i = 0;
//	for (i = 0; i < sz; i++)
//	{
//		printf("%d ", arr[i]);
//	}
//
//	return 0;
//}



//数组名是什么？


//int main()
//{
//	int arr[] = {2,4};
//	
//	//printf("%p\n", arr);	 //012FFA5C
//	//printf("%p\n", &arr[0]); //012FFA5C
//	////从上边可以看出，数组名是首元素的地址
//	////验证
//	//printf("%d\n", *arr);	 //2
//
//	//数组名是首元素的地址，但是有两个例外
//	//1. sizeof（数组名） 这里的数组名表示整个数组
//	//2. &数组名  这里的数组名也表示整个数组，
//	// 从值的角度来看，和首元素的地址值是相同的,
//	// 但是数组地址+1会把整个数组跳过去，首元素地址+1只会跳过第一个元素的地址
//	
//	
//
//	//1.
//	//int n = sizeof(arr);
//	//printf("%d\n",n);
//
//	//2.
//	printf("%p\n", arr); //首元素的地址      0053FAB0
//	printf("%p\n", arr+1);//                 0053FAB4	
//	printf("---------------------\n");
//	printf("%p\n", &arr[0]); //首元素的地址  0053FAB0
//	printf("%p\n", &arr[0] + 1);//		     0053FAB4	
//	printf("---------------------\n");
//
//	printf("%p\n", &arr);   //数组的地址     0053FAB0
//	printf("%p\n", &arr+1); //               0053FAB8
//
//
//	return 0;
//}


//二维数组的数组名的理解

int main()
{
	int arr[3][4];
	printf("%d\n",sizeof(arr));

	arr;//二维数组的数组名也表示首元素的地址（第一行的地址，把第一行看成首元素）值和arr[0][0]的地址的值一样
		//但是+1会有不一样的效果
	printf("%p\n", arr);//      0110FE08
	printf("%p\n", arr+1);//    0110FE18
	//地址以16进制表示，差了10 即10进制的16

	//二维数组求行和列
	//行 ： 总数组的大小除以一行的大小

	printf("%d\n", sizeof(arr) / sizeof(arr[0]));// 48/16

	//列： 一行的大小除以，一个元素的大小
	printf("%d\n", sizeof(arr[0]) / sizeof(arr[0][0]));// 16/4
	
	return 0;
}


//int main()
//{
//
//
//	return 0;
//}
